<?xml version="1.0" encoding="UTF-8"?>
<!--Designed and generated by Altova StyleVision Basic Edition 2018 rel. 2 sp1 - see http://www.altova.com/stylevision for more information.-->
<xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:altova="http://www.altova.com" xmlns:altova-xfi="http://www.altova.com/xslt-extensions/xbrl" xmlns:altovaext="http://www.altova.com/xslt-extensions" xmlns:array="http://www.w3.org/2005/xpath-functions/array" xmlns:clitype="clitype" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:iso4217="http://www.xbrl.org/2003/iso4217" xmlns:java="java" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" xmlns:link="http://www.xbrl.org/2003/linkbase" xmlns:map="http://www.w3.org/2005/xpath-functions/map" xmlns:math="http://www.w3.org/2005/xpath-functions/math" xmlns:sps="http://www.altova.com/StyleVision/user-xpath-functions" xmlns:vdm_data="verdict::vdm::vdm_data" xmlns:vdm_lustre="verdict::vdm::vdm_lustre" xmlns:vdm_model="verdict::vdm::vdm_model" xmlns:xbrldi="http://xbrl.org/2006/xbrldi" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns:xff="http://www.xbrl.org/2010/function/formula" xmlns:xfi="http://www.xbrl.org/2008/function/instance" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" exclude-result-prefixes="#all">
	<xsl:output version="5.0" method="html" indent="no" encoding="UTF-8" use-character-maps="spaces"/>
	<xsl:character-map name="spaces">
		<xsl:output-character character="&#160;" string="&amp;#160;"/>
	</xsl:character-map>
	<xsl:param name="altova:bGeneratingFromPxf" select="false()"/>
	<xsl:param name="SV_OutputFormat" select="'HTML'"/>
	<xsl:param name="SV_BaseOutputFileName" as="xs:string?">
		<xsl:sequence select="for $i in altovaext:get-base-output-uri(), $j in tokenize( $i, &apos;[/\\]&apos; )[last()] return replace( $j, &apos;\.[^\.\s#%;]*$&apos;, &apos;&apos; )" use-when="function-available(&apos;altovaext:get-base-output-uri&apos;)"/>
	</xsl:param>
	<xsl:param name="quote">"</xsl:param>
	<xsl:param name="SV_GeneratedFileNamePrefix" select="if ( $SV_BaseOutputFileName ) then $SV_BaseOutputFileName else &apos;VdmToLustre&apos;" as="xs:string?"/>
	<xsl:variable name="XML" select="/"/>
	<xsl:variable name="altova:nPxPerIn" select="96"/>
	<xsl:import-schema schema-location="../../../../../../verdict/com.ge.research.osate.verdict.vdm/src/main/resources/vdm_model.xsd" use-when="system-property('xsl:is-schema-aware')='yes'" namespace="verdict::vdm::vdm_model"/>
	<xsl:variable name="altova:CssImages" select="()"/>
	<xsl:template match="/">
		<xsl:call-template name="altova:Root"/>
	</xsl:template>
	<xsl:template name="altova:Root">
		<html>
			<head>
				<title/>
				<meta name="generator" content="Altova StyleVision Basic Edition 2018 rel. 2 sp1 (http://www.altova.com)"/>
				<meta http-equiv="X-UA-Compatible" content="IE=9"/>
				<xsl:comment>[if IE]&gt;&lt;STYLE type=&quot;text/css&quot;&gt;.altova-rotate-left-textbox{filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3)} .altova-rotate-right-textbox{filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1)} &lt;/STYLE&gt;&lt;![endif]</xsl:comment>
				<xsl:comment>[if !IE]&gt;&lt;!</xsl:comment>
				<style type="text/css">.altova-rotate-left-textbox{-webkit-transform: rotate(-90deg) translate(-100%, 0%); -webkit-transform-origin: 0% 0%;-moz-transform: rotate(-90deg) translate(-100%, 0%); -moz-transform-origin: 0% 0%;-ms-transform: rotate(-90deg) translate(-100%, 0%); -ms-transform-origin: 0% 0%;}.altova-rotate-right-textbox{-webkit-transform: rotate(90deg) translate(0%, -100%); -webkit-transform-origin: 0% 0%;-moz-transform: rotate(90deg) translate(0%, -100%); -moz-transform-origin: 0% 0%;-ms-transform: rotate(90deg) translate(0%, -100%); -ms-transform-origin: 0% 0%;}</style>
				<xsl:comment>&lt;![endif]</xsl:comment>
				<style type="text/css">@page { margin-left:1.000in; margin-right:1.000in; margin-top:1.000in; margin-bottom:1.000in } @media print { br.altova-page-break { page-break-before: always; } div.altova-page-break { page-break-before: always; } }</style>
			</head>
			<body style="font-family:Courier; font-size:10pt; font-weight:normal; line-height:10pt; text-align:left; white-space:nowrap; ">
				<xsl:for-each select="$XML">
					<xsl:for-each select="vdm_model:model">
						<xsl:for-each select="dataflowCode">
							<xsl:call-template name="TypeDeclarations"/>
							<br/>
							<xsl:call-template name="ConstantDeclarations"/>
							<br/>
							<xsl:call-template name="ContractDeclarations"/>
							<br/>
							<xsl:call-template name="NodeDeclarations"/>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</body>
		</html>
	</xsl:template>
	<xsl:template name="InputParameters">
		<xsl:choose>
			<xsl:when test="boolean(vdm_lustre:inputParameter/node())">
				<xsl:for-each select="vdm_lustre:inputParameter">
					<br/>
					<span>
						<xsl:text>&#160; </xsl:text>
					</span>
					<xsl:if test="position() = 1">
						<span>
							<xsl:text>(</xsl:text>
						</span>
					</xsl:if>
					<xsl:if test="string(@vdm_lustre:isConstant) = (&apos;true&apos;, &apos;1&apos;)">
						<span>
							<xsl:text>const </xsl:text>
						</span>
					</xsl:if>
					<xsl:for-each select="vdm_lustre:name">
						<xsl:apply-templates/>
					</xsl:for-each>
					<xsl:for-each select="vdm_lustre:dataType">
						<span>
							<xsl:text> : </xsl:text>
						</span>
						<xsl:call-template name="DataType"/>
					</xsl:for-each>
					<xsl:choose>
						<xsl:when test="position() = last()">
							<span>
								<xsl:text>)</xsl:text>
							</span>
						</xsl:when>
						<xsl:otherwise>
							<span>
								<xsl:text>;</xsl:text>
							</span>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:when>
			<xsl:otherwise>
				<br/>
				<span>
					<xsl:text>&#160; ()</xsl:text>
				</span>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="EnumValues">
		<xsl:for-each select="vdm_data:enumValue">
			<xsl:apply-templates/>
			<xsl:choose>
				<xsl:when test="position() = last()"/>
				<xsl:otherwise>
					<span>
						<xsl:text>, </xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="DataType">
		<xsl:for-each select="vdm_data:plainType">
			<xsl:apply-templates/>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:subrangeType">
			<span>
				<xsl:text>subrange [</xsl:text>
			</span>
			<xsl:for-each select="vdm_data:lowerBound">
				<xsl:apply-templates/>
			</xsl:for-each>
			<span>
				<xsl:text>, </xsl:text>
			</span>
			<xsl:for-each select="vdm_data:upperBound">
				<xsl:apply-templates/>
			</xsl:for-each>
			<span>
				<xsl:text>] of </xsl:text>
			</span>
			<xsl:for-each select="@vdm_data:type">
				<span>
					<xsl:value-of select="string(.)"/>
				</span>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:arrayType">
			<xsl:for-each select="vdm_data:dataType">
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<span>
				<xsl:text>^</xsl:text>
			</span>
			<xsl:for-each select="vdm_data:dimension">
				<xsl:apply-templates/>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:tupleType">
			<span>
				<xsl:text>[</xsl:text>
			</span>
			<xsl:for-each select="vdm_data:dataType">
				<xsl:call-template name="DataType"/>
				<xsl:choose>
					<xsl:when test="position() = last()"/>
					<xsl:otherwise>
						<span>
							<xsl:text>, </xsl:text>
						</span>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			<span>
				<xsl:text>]</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:userDefinedType">
			<xsl:apply-templates/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="RecordFields">
		<xsl:for-each select="vdm_data:recordField">
			<xsl:for-each select="vdm_data:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_data:type">
				<span>
					<xsl:text> : </xsl:text>
				</span>
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<xsl:choose>
				<xsl:when test="position() = last()"/>
				<xsl:otherwise>
					<span>
						<xsl:text>; </xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="OutputParameters">
		<xsl:choose>
			<xsl:when test="boolean(vdm_lustre:outputParameter/node())">
				<xsl:for-each select="vdm_lustre:outputParameter">
					<br/>
					<span>
						<xsl:text>&#160; </xsl:text>
					</span>
					<xsl:if test="position() = 1">
						<span>
							<xsl:text>(</xsl:text>
						</span>
					</xsl:if>
					<xsl:for-each select="vdm_lustre:name">
						<xsl:apply-templates/>
					</xsl:for-each>
					<xsl:for-each select="vdm_lustre:dataType">
						<span>
							<xsl:text> : </xsl:text>
						</span>
						<xsl:call-template name="DataType"/>
					</xsl:for-each>
					<xsl:choose>
						<xsl:when test="position() = last()">
							<span>
								<xsl:text>);</xsl:text>
							</span>
						</xsl:when>
						<xsl:otherwise>
							<span>
								<xsl:text>;</xsl:text>
							</span>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:when>
			<xsl:otherwise>
				<br/>
				<span>
					<xsl:text>&#160; ();</xsl:text>
				</span>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="LocalVariables">
		<xsl:for-each select="vdm_lustre:variableDeclaration">
			<xsl:if test="position() = 1">
				<span>
					<xsl:text>var</xsl:text>
				</span>
				<br/>
			</xsl:if>
			<span>
				<xsl:text>&#160; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:dataType">
				<span>
					<xsl:text> : </xsl:text>
				</span>
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Expression">
		<xsl:for-each select="vdm_lustre:identifier">
			<xsl:apply-templates/>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:boolLiteral">
			<xsl:apply-templates/>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:intLiteral">
			<xsl:apply-templates/>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:realLiteral">
			<span>
				<xsl:variable name="altova:seqContentStrings_0">
					<xsl:value-of select="format-number(number(string(.)), '#0.0###############')"/>
				</xsl:variable>
				<xsl:variable name="altova:sContent_0" select="string($altova:seqContentStrings_0)"/>
				<xsl:value-of select="$altova:sContent_0"/>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:expressionList">
			<span>
				<xsl:text>(</xsl:text>
			</span>
			<xsl:call-template name="Expressions"/>
			<span>	
				<xsl:text>)</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:recordLiteral">
			<xsl:for-each select="@vdm_lustre:recordType">
				<span>
					<xsl:value-of select="string(.)"/>
				</span>
			</xsl:for-each>
			<span>
				<xsl:text> { </xsl:text>
			</span>
			<xsl:call-template name="RecordFieldDefinitions"/>
			<span>
				<xsl:text> }</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:arrayExpression">
			<span>
				<xsl:text>[</xsl:text>
			</span>
			<xsl:call-template name="Expressions"/>
			<span>
				<xsl:text>]</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:cartesianExpression">
			<xsl:for-each select="vdm_lustre:lhsOperand">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>^</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:tupleExpression">
			<span>
				<xsl:text>{</xsl:text>
			</span>
			<xsl:call-template name="Expressions"/>
			<span>
				<xsl:text>}</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:negative">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>		
			<span>
				<xsl:text>-</xsl:text>
			</span>
		  	<span>
				<xsl:text>(</xsl:text>
			</span>			
			<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>		
			<span>
				<xsl:text>)</xsl:text>
			</span>				
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:pre">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>
			<span>
				<xsl:text>pre </xsl:text>
			</span>
		  	<span>
				<xsl:text>(</xsl:text>
			</span>			
			<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>			
			 <span>
				<xsl:text>)</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:current">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>		
			<span>
				<xsl:text>current </xsl:text>
			</span>
		  	<span>
				<xsl:text>(</xsl:text>
			</span>			
			<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>			
		  	<span>
				<xsl:text>)</xsl:text>
			</span>			
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:toInt">
			<span>
				<xsl:text>int </xsl:text>
			</span>
			<xsl:call-template name="Expression"/>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:toReal">
			<span>
				<xsl:text>real </xsl:text>
			</span>
			<xsl:call-template name="Expression"/>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:when">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>										
			<xsl:for-each select="vdm_lustre:lhsOperand">
			<span>
				<xsl:text>(</xsl:text>
			</span>						
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>							
			</xsl:for-each>
			<span>
				<xsl:text> when </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>						
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>							
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>									
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:times">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>						
			<xsl:for-each select="vdm_lustre:lhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>							
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>								
			</xsl:for-each>
			<span>
				<xsl:text> * </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>							
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>								
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>							
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:div">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>						
			<xsl:for-each select="vdm_lustre:lhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>							
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>								
			</xsl:for-each>
			<span>
				<xsl:text> / </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>							
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>								
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>							
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:mod">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>				
			<xsl:for-each select="vdm_lustre:lhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>					
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>						
			</xsl:for-each>
			<span>
				<xsl:text> mod </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>					
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>						
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>					
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:intDiv">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>				
			<xsl:for-each select="vdm_lustre:lhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>					
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>						
			</xsl:for-each>
			<span>
				<xsl:text> div </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>					
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>						
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>					
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:plus">
			<span>
				<xsl:text>(</xsl:text>
			</span>				
			<xsl:for-each select="vdm_lustre:lhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>					
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>						
			</xsl:for-each>
			<span>
				<xsl:text> + </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>					
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>						
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>					
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:minus">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>		
			<xsl:for-each select="vdm_lustre:lhsOperand">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>			
				<xsl:call-template name="Expression"/>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>				
			</xsl:for-each>
			<span>
				<xsl:text> - </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>			
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>				
			</xsl:for-each>
		  	<span>
				<xsl:text>)</xsl:text>
			</span>			
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:not">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>
			<span>
				<xsl:text>not </xsl:text>
			</span>
  			<span>
				<xsl:text>(</xsl:text>
			</span>								
			<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>								
 			<span>
				<xsl:text>)</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:lessThan">
  			<span>
				<xsl:text>(</xsl:text>
			</span>					
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>			
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>	
			</xsl:for-each>
			<span>
				<xsl:text> &lt; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>			
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>				
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>						
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:lessThanOrEqualTo">
  			<span>
				<xsl:text>(</xsl:text>
			</span>							
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>								
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>									
			</xsl:for-each>
			<span>
				<xsl:text> &lt;= </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>								
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>									
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>								
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:equal">
  			<span>
				<xsl:text>(</xsl:text>
			</span>							
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>								
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>									
			</xsl:for-each>
			<span>
				<xsl:text> = </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
 			<span>
				<xsl:text>(</xsl:text>
			</span>
				<xsl:call-template name="Expression"/>
			<span>		
				<xsl:text>)</xsl:text>
			</span>
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>								
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:greaterThanOrEqualTo">
		  	<span>
				<xsl:text>(</xsl:text>
			</span>							
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> &gt;= </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:greaterThan">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  				<span>
					<xsl:text>(</xsl:text>
				</span>										
				<xsl:call-template name="Expression"/>
	  			<span>
					<xsl:text>)</xsl:text>
				</span>											
			</xsl:for-each>
			<span>
				<xsl:text> &gt; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:notEqual">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> &lt;&gt; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:and">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> and </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:or">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> or </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
			  <span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:xor">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> xor </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:implies">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> =&gt; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:arrow">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> -&gt; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:concat">
  			<span>
				<xsl:text>(</xsl:text>
			</span>											
			<xsl:for-each select="vdm_lustre:lhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>												
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>													
			</xsl:for-each>
			<span>
				<xsl:text> | </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhsOperand">
  			<span>
				<xsl:text>(</xsl:text>
			</span>												
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>													
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>												
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:diese">
			<span>
				<xsl:text>#(</xsl:text>
			</span>
			<xsl:call-template name="Expressions"/>
			<span>
				<xsl:text>)</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:nor">
			<span>
				<xsl:text>nor(</xsl:text>
			</span>
			<xsl:call-template name="Expressions"/>
			<span>
				<xsl:text>)</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:conditionalExpression">
  			<span>
				<xsl:text>(</xsl:text>
			</span>									
			<span>
				<xsl:text>if </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:condition">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> then </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:thenBranch">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
			<span>
				<xsl:text> else </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:elseBranch">
  			<span>
				<xsl:text>(</xsl:text>
			</span>										
				<xsl:call-template name="Expression"/>
  			<span>
				<xsl:text>)</xsl:text>
			</span>											
			</xsl:for-each>
  			<span>
				<xsl:text>)</xsl:text>
			</span>										
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:call">
			<xsl:for-each select="@vdm_lustre:nodeId">
				<span>
					<xsl:value-of select="string(.)"/>
				</span>
			</xsl:for-each>
			<span>
				<xsl:text>(</xsl:text>
			</span>
			<xsl:call-template name="Arguments"/>
			<span>
				<xsl:text>)</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:recordProjection">
			<xsl:for-each select="vdm_lustre:recordReference">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>.</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:fieldId">
				<xsl:apply-templates/>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:arraySelection">
			<xsl:for-each select="vdm_lustre:array">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>[</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:selector">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:trancheEnd">
				<span>
					<xsl:text>..</xsl:text>
				</span>
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:sliceStep">
				<span>
					<xsl:text> step </xsl:text>
				</span>
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>]</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_lustre:merge">
			<span>
				<xsl:text>merge </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:clock">
				<xsl:apply-templates/>
			</xsl:for-each>
			<span>
				<xsl:text>&#160;</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:mergeCase">
				<span>
					<xsl:text>(</xsl:text>
				</span>
				<xsl:for-each select="vdm_lustre:case">
					<xsl:apply-templates/>
				</xsl:for-each>
				<span>
					<xsl:text> -&gt; </xsl:text>
				</span>
				<xsl:for-each select="vdm_lustre:expr">
					<xsl:call-template name="Expression"/>
				</xsl:for-each>
				<span>
					<xsl:text>)</xsl:text>
				</span>
			</xsl:for-each>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Arguments">
		<xsl:for-each select="vdm_lustre:argument">
			<xsl:call-template name="Expression"/>
			<xsl:choose>
				<xsl:when test="position() = last()"/>
				<xsl:otherwise>
					<span>
						<xsl:text>, </xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="RecordFieldDefinitions">
		<xsl:for-each select="vdm_lustre:fieldDefinition">
			<xsl:for-each select="vdm_lustre:fieldIdentifier">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:fieldValue">
				<span>
					<xsl:text> = </xsl:text>
				</span>
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<xsl:choose>
				<xsl:when test="position() = last()"/>
				<xsl:otherwise>
					<span>
						<xsl:text>; </xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Expressions">
		<xsl:for-each select="vdm_lustre:expression">
			<xsl:call-template name="Expression"/>
			<xsl:choose>
				<xsl:when test="position() = last()"/>
				<xsl:otherwise>
					<span>
						<xsl:text>, </xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Assumes">
		<xsl:for-each select="vdm_lustre:assume">
			<span>
				<xsl:text>&#160; assume </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
			<xsl:value-of select="$quote"/>	
				<xsl:apply-templates/>
				<xsl:value-of select="$quote"/>				
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
			</xsl:for-each>			
			<xsl:for-each select="vdm_lustre:expression">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
		<xsl:template name="WeaklyAssumes">
		<xsl:for-each select="vdm_lustre:weaklyassume">
			<span>
				<xsl:text>&#160; weakly assume </xsl:text>
			</span>
						<xsl:for-each select="vdm_lustre:name">
			<xsl:value-of select="$quote"/>	
				<xsl:apply-templates/>
				<xsl:value-of select="$quote"/>				
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
			</xsl:for-each>			
			<span>
				<xsl:text>(</xsl:text>
			</span>						
			<xsl:for-each select="vdm_lustre:expression">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>)</xsl:text>
			</span>			
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>	
	<xsl:template name="Guarantees">
		<xsl:for-each select="vdm_lustre:guarantee">
			<span>
				<xsl:text>&#160; guarantee </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
			<xsl:value-of select="$quote"/>	
				<xsl:apply-templates/>
				<xsl:value-of select="$quote"/>				
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:expression">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Imports">
		<xsl:for-each select="vdm_lustre:import">
			<span>
				<xsl:text>&#160; import </xsl:text>
			</span>
			<xsl:for-each select="@vdm_lustre:contractId">
				<span>
					<xsl:value-of select="string(.)"/>
				</span>
			</xsl:for-each>
			<span>
				<xsl:text> (</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:inputArgument">
				<xsl:call-template name="Expression"/>
				<xsl:choose>
					<xsl:when test="position() = last()"/>
					<xsl:otherwise>
						<span>
							<xsl:text>, </xsl:text>
						</span>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			<span>
				<xsl:text>) returns (</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:outputArgument">
				<xsl:call-template name="Expression"/>
				<xsl:choose>
					<xsl:when test="position() = last()"/>
					<xsl:otherwise>
						<span>
							<xsl:text>, </xsl:text>
						</span>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			<span>
				<xsl:text>);</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Equations">
		<xsl:for-each select="vdm_lustre:equation">
			<span>
				<xsl:text>&#160; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:lhs">
				<xsl:choose>
					<xsl:when test="boolean(vdm_lustre:identifier/node())">
						<xsl:for-each select="vdm_lustre:identifier">
							<xsl:apply-templates/>
							<xsl:choose>
								<xsl:when test="position() = last()"/>
								<xsl:otherwise>
									<span>
										<xsl:text>, </xsl:text>
									</span>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:for-each>
					</xsl:when>
					<xsl:otherwise>
						<span>
							<xsl:text>()</xsl:text>
						</span>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			<span>
				<xsl:text> = </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:rhs">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="TypeDeclarations">
		<xsl:for-each select="vdm_lustre:typeDeclaration">
			<span>
				<xsl:text>type </xsl:text>
			</span>
			<xsl:for-each select="vdm_data:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_data:definition">
				<span>
					<xsl:text> = </xsl:text>
				</span>
				<xsl:call-template name="TypeDefinition"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="ContractDeclarations">
		<xsl:for-each select="vdm_lustre:contractDeclaration">
			<span>
				<xsl:text>contract </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:call-template name="InputParameters"/>
			<br/>
			<span>
				<xsl:text>returns</xsl:text>
			</span>
			<xsl:call-template name="OutputParameters"/>
			<br/>
			<xsl:for-each select="vdm_lustre:specification">
				<span>
					<xsl:text>let</xsl:text>
				</span>
				<br/>
				<xsl:call-template name="Symbols"/>
				<xsl:call-template name="Assumes"/>
				<xsl:call-template name="WeaklyAssumes"/>
				<xsl:call-template name="Guarantees"/>
				<xsl:call-template name="Modes"/>
				<xsl:call-template name="Imports"/>
				<span>
					<xsl:text>tel</xsl:text>
				</span>
				<br/>
			</xsl:for-each>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="NodeDeclarations">
		<xsl:for-each select="vdm_lustre:nodeDeclaration">
			<xsl:choose>
				<xsl:when test="string(@vdm_lustre:isFunction) = (&apos;true&apos;, &apos;1&apos;)">
					<span>
						<xsl:text>function</xsl:text>
					</span>
				</xsl:when>
				<xsl:otherwise>
					<span>
						<xsl:text>node</xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="string(@vdm_lustre:isImported) = (&apos;true&apos;, &apos;1&apos;)">
				<span>
					<xsl:text> imported</xsl:text>
				</span>
			</xsl:if>
			<span>
				<xsl:text>&#160;</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:call-template name="InputParameters"/>
			<br/>
			<span>
				<xsl:text>returns</xsl:text>
			</span>
			<xsl:call-template name="OutputParameters"/>
			<br/>
			<xsl:for-each select="vdm_lustre:contract">
				<span>
					<xsl:text>(*@contract</xsl:text>
				</span>
				<br/>
				<xsl:call-template name="Symbols"/>
				<xsl:call-template name="Assumes"/>
				<xsl:call-template name="WeaklyAssumes"/>				
				<xsl:call-template name="Guarantees"/>
				<xsl:call-template name="Modes"/>
				<xsl:call-template name="Imports"/>
				<span>
					<xsl:text>*)</xsl:text>
				</span>
				<br/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:body">
				<xsl:call-template name="LocalConstants"/>
				<xsl:call-template name="LocalVariables"/>
				<span>
					<xsl:text>let</xsl:text>
				</span>
				<br/>
				<xsl:call-template name="Assertions"/>
				<xsl:call-template name="Equations"/>
				<xsl:call-template name="Main"/>
				<xsl:call-template name="Properties"/>
				<span>
					<xsl:text>tel</xsl:text>
				</span>
				<br/>
			</xsl:for-each>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="ConstantDeclarations">
		<xsl:for-each select="vdm_lustre:constantDeclaration">
			<span>
				<xsl:text>const </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:dataType">
				<span>
					<xsl:text> : </xsl:text>
				</span>
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:definition">
				<span>
					<xsl:text> = </xsl:text>
				</span>
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="TypeDefinition">
		<xsl:for-each select="vdm_data:plainType">
			<xsl:apply-templates/>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:subrangeType">
			<span>
				<xsl:text>subrange [</xsl:text>
			</span>
			<xsl:for-each select="vdm_data:lowerBound">
				<xsl:apply-templates/>
			</xsl:for-each>
			<span>
				<xsl:text>, </xsl:text>
			</span>
			<xsl:for-each select="vdm_data:upperBound">
				<xsl:apply-templates/>
			</xsl:for-each>
			<span>
				<xsl:text>] of </xsl:text>
			</span>
			<xsl:for-each select="@vdm_data:type">
				<span>
					<xsl:value-of select="string(.)"/>
				</span>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:arrayType">
			<xsl:for-each select="vdm_data:dataType">
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<span>
				<xsl:text>^</xsl:text>
			</span>
			<xsl:for-each select="vdm_data:dimension">
				<xsl:apply-templates/>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:tupleType">
			<span>
				<xsl:text>[</xsl:text>
			</span>
			<xsl:for-each select="vdm_data:dataType">
				<xsl:call-template name="DataType"/>
				<xsl:choose>
					<xsl:when test="position() = last()"/>
					<xsl:otherwise>
						<span>
							<xsl:text>, </xsl:text>
						</span>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			<span>
				<xsl:text>]</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:enumType">
			<span>
				<xsl:text>enum { </xsl:text>
			</span>
			<xsl:call-template name="EnumValues"/>
			<span>
				<xsl:text> }</xsl:text>
			</span>
		</xsl:for-each>
		<xsl:for-each select="vdm_data:recordType">
			<span>
				<xsl:text>struct { </xsl:text>
			</span>
			<xsl:call-template name="RecordFields"/>
			<span>
				<xsl:text> }</xsl:text>
			</span>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="LocalConstants">
		<xsl:for-each select="vdm_lustre:constantDeclaration">
			<xsl:if test="position() = 1">
				<span>
					<xsl:text>const</xsl:text>
				</span>
				<br/>
			</xsl:if>
			<span>
				<xsl:text>&#160; </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:dataType">
				<span>
					<xsl:text> : </xsl:text>
				</span>
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:definition">
				<span>
					<xsl:text> = </xsl:text>
				</span>
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Properties">
		<xsl:for-each select="vdm_lustre:property">
			<span>
				<xsl:text>&#160; --%PROPERTY </xsl:text>
			</span>
			<xsl:for-each select="@vdm_lustre:name">
				<span>
					<xsl:value-of select="string(.)"/>
				</span>
				<span>
					<xsl:text>&#160;</xsl:text>
				</span>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:expression">
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Main">
		<xsl:if test="string(@vdm_lustre:isMain) = (&apos;true&apos;, &apos;1&apos;)">
			<span>
				<xsl:text>&#160; --%MAIN;</xsl:text>
			</span>
			<br/>
		</xsl:if>
	</xsl:template>
	<xsl:template name="Assertions">
		<xsl:for-each select="vdm_lustre:assertion">
			<span>
				<xsl:text>&#160; assert </xsl:text>
			</span>
			<xsl:call-template name="Expression"/>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Symbols">
		<xsl:for-each select="vdm_lustre:symbol">
			<span>
				<xsl:text>&#160; </xsl:text>
			</span>
			<xsl:choose>
				<xsl:when test="string(@vdm_lustre:isConstant) = (&apos;true&apos;, &apos;1&apos;)">
					<span>
						<xsl:text>const</xsl:text>
					</span>
				</xsl:when>
				<xsl:otherwise>
					<span>
						<xsl:text>var</xsl:text>
					</span>
				</xsl:otherwise>
			</xsl:choose>
			<span>
				<xsl:text>&#160;</xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:dataType">
				<span>
					<xsl:text> : </xsl:text>
				</span>
				<xsl:call-template name="DataType"/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:definition">
				<span>
					<xsl:text> = </xsl:text>
				</span>
				<xsl:call-template name="Expression"/>
			</xsl:for-each>
			<span>
				<xsl:text>;</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="Modes">
		<xsl:for-each select="vdm_lustre:mode">
			<span>
				<xsl:text>&#160; mode </xsl:text>
			</span>
			<xsl:for-each select="vdm_lustre:name">
				<xsl:apply-templates/>
			</xsl:for-each>
			<span>
				<xsl:text> (</xsl:text>
			</span>
			<br/>
			<xsl:for-each select="vdm_lustre:require">
				<span>
					<xsl:text>&#160;&#160;&#160; require </xsl:text>
				</span>
				<xsl:for-each select="vdm_lustre:expression">
					<xsl:call-template name="Expression"/>
				</xsl:for-each>
				<span>
					<xsl:text>;</xsl:text>
				</span>
				<br/>
			</xsl:for-each>
			<xsl:for-each select="vdm_lustre:ensure">
				<span>
					<xsl:text>&#160;&#160;&#160; ensure </xsl:text>
				</span>
				<xsl:for-each select="vdm_lustre:expression">
					<xsl:call-template name="Expression"/>
				</xsl:for-each>
				<span>
					<xsl:text>;</xsl:text>
				</span>
				<br/>
			</xsl:for-each>
			<span>
				<xsl:text>&#160; );</xsl:text>
			</span>
			<br/>
		</xsl:for-each>
	</xsl:template>
	<xsl:function name="altova:is-cell-empty" as="xs:boolean">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="altova:is-node-empty( $altova:cell )"/>
	</xsl:function>
	<xsl:function name="altova:is-node-empty" as="xs:boolean" xpath-default-namespace="">
		<xsl:param name="altova:node" as="element()"/>
		<xsl:sequence select="every $altova:child in $altova:node/child::node() satisfies ( ( boolean( $altova:child/self::text() ) and string-length( $altova:child ) = 0 ) or ( ( boolean( $altova:child/self::div ) or boolean( $altova:child/self::span ) or boolean( $altova:child/self::a ) ) and altova:is-node-empty( $altova:child ) ) )"/>
	</xsl:function>
	<xsl:function name="altova:col-span" as="xs:integer">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="if ( exists( $altova:cell/@colspan ) ) then xs:integer( $altova:cell/@colspan ) else 1"/>
	</xsl:function>
	<xsl:template match="@* | node()" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:param name="altova:TableIndexInfo"/>
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current">
				<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
				<xsl:with-param name="altova:TableIndexInfo" select="$altova:TableIndexInfo"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="tbody" mode="altova:generate-table" xpath-default-namespace="">
		<xsl:param name="altova:generate-cols"/>
		<xsl:param name="altova:TableIndexInfo"/>
		<xsl:choose>
			<xsl:when test="empty(tr)">
				<xsl:copy>
					<tr>
						<td/>
					</tr>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current">
						<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
						<xsl:with-param name="altova:TableIndexInfo" select="$altova:TableIndexInfo"/>
					</xsl:apply-templates>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="th | td" mode="altova:generate-table" xpath-default-namespace="">
		<xsl:choose>
			<xsl:when test="altova:is-cell-empty( . )">
				<xsl:copy>
					<xsl:apply-templates select="@*" mode="#current"/>
					<xsl:text>&#160;</xsl:text>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="altova:CountLeadingTrueValues">
		<xsl:param name="seqBools"/>
		<xsl:sequence select="if (not($seqBools[1] = true())) then 0 else 1 + altova:CountLeadingTrueValues($seqBools[position() gt 1])"/>
	</xsl:function>
	<xsl:function name="altova:GetCellFromRow" as="node()?" xpath-default-namespace="">
		<xsl:param name="nodeTableRow" as="node()"/>
		<xsl:param name="nCell" as="xs:integer"/>
		<xsl:sequence select="$nodeTableRow/(th | td)[$nCell]"/>
	</xsl:function>
	<xsl:function name="altova:GetCellsFromRow" as="node()*" xpath-default-namespace="">
		<xsl:param name="nodeTableRow" as="node()"/>
		<xsl:sequence select="$nodeTableRow/(th | td)"/>
	</xsl:function>
	<xsl:function name="altova:GetRowsFromTable" as="node()*" xpath-default-namespace="">
		<xsl:param name="nodeTable" as="node()"/>
		<xsl:sequence select="$nodeTable/(thead | tbody | tfoot)/tr"/>
	</xsl:function>
	<xsl:function name="altova:GetRowspanFromCell" as="xs:integer" xpath-default-namespace="">
		<xsl:param name="altova:nodeCell" as="node()"/>
		<xsl:variable name="altova:sRowSpan" select="$altova:nodeCell/@rowspan" as="xs:string?"/>
		<xsl:variable name="altova:nRowSpan" select="if ($altova:sRowSpan) then xs:integer($altova:sRowSpan) else 1" as="xs:integer"/>
		<xsl:sequence select="$altova:nRowSpan"/>
	</xsl:function>
	<!-- In HTML and FO, the table section order is header, footer, body. This function determines, for a given cell, the number its row would have if the section order were header, body, footer -->
	<xsl:function name="altova:GetGridRowNumForCell" xpath-default-namespace="">
		<xsl:param name="altova:nodeTableCell" as="node()"/>
		<xsl:variable name="altova:nodeTableRow" select="$altova:nodeTableCell/.." as="node()"/>
		<xsl:variable name="altova:nodeTableSection" select="$altova:nodeTableRow/.." as="node()"/>
		<xsl:variable name="altova:sTableSection" select="fn:local-name($altova:nodeTableSection)" as="xs:string"/>
		<xsl:variable name="altova:nodeTable" select="$altova:nodeTableSection/.." as="node()"/>
		<xsl:variable name="altova:nRowNumInSection" select="count($altova:nodeTableRow/preceding-sibling::tr) + 1" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:sTableSection eq 'tbody'">
				<xsl:sequence select="count($altova:nodeTable/thead/tr) + $altova:nRowNumInSection"/>
			</xsl:when>
			<xsl:when test="$altova:sTableSection eq 'thead'">
				<xsl:sequence select="$altova:nRowNumInSection"/>
			</xsl:when>
			<xsl:when test="$altova:sTableSection eq 'tfoot'">
				<xsl:sequence select="count($altova:nodeTable/thead/tr) + count($altova:nodeTable/tbody/tr) + $altova:nRowNumInSection"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message select="'Internal Error'" terminate="yes"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:BuildTableIndexInfo" as="node()" xpath-default-namespace="">
		<xsl:param name="altova:nodeTable" as="node()"/>
		<altova:ColumnIndices>
			<xsl:variable name="altova:nodeAllRows" select="altova:GetRowsFromTable($altova:nodeTable/table)" as="node()*"/>
			<xsl:if test="$altova:nodeAllRows">
				<xsl:variable name="altova:seqCellsInFirstRow" select="altova:GetCellsFromRow($altova:nodeAllRows[1])" as="node()*"/>
				<xsl:variable name="altova:nColumnsInTable" select="sum(for $nodeCell in $altova:seqCellsInFirstRow return altova:col-span($nodeCell))" as="xs:integer"/>
				<xsl:variable name="altova:seqActiveRowSpans" select="for $Cell in 1 to $altova:nColumnsInTable return 0" as="xs:integer*"/>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_Recursive($altova:nodeAllRows, 1, $altova:seqActiveRowSpans)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_Recursive">
					<xsl:with-param name="altova:nodeTableRows" select="$altova:nodeAllRows"/>
					<xsl:with-param name="altova:nRow" select="1"/>
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
				</xsl:call-template>
			</xsl:if>
		</altova:ColumnIndices>
	</xsl:function>
	<!--xsl:template name="altova:BuildTableIndexInfo_Recursive" as="node()*" xpath-default-namespace=""-->
	<xsl:template name="altova:BuildTableIndexInfo_Recursive" xpath-default-namespace="">
		<xsl:param name="altova:nodeTableRows" as="node()*"/>
		<xsl:param name="altova:nRow" as="xs:integer"/>
		<xsl:param name="altova:seqActiveRowSpans" as="xs:integer*"/>
		<xsl:variable name="altova:nodeRow" select="$altova:nodeTableRows[$altova:nRow]" as="node()?"/>
		<xsl:choose>
			<xsl:when test="empty($altova:nodeRow)">
				<xsl:sequence select="()"/>
			</xsl:when>
			<xsl:when test="empty(altova:GetCellFromRow($altova:nodeRow, 1))">
				<xsl:sequence select="()"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:nodeCell1" select="altova:GetCellFromRow($altova:nodeRow, 1)" as="node()?"/>
				<xsl:variable name="altova:nColSpan" select="altova:col-span($altova:nodeCell1)" as="xs:integer"/>
				<altova:Row>
					<!--xsl:variable name="altova:seqColumnIndicesOfCurrentRow" select="altova:BuildTableIndexInfo_SingleRow_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, 1, 1, $altova:nColSpan, true(), 0, 0)" as="node()*"/>
						<xsl:sequence select="$altova:seqColumnIndicesOfCurrentRow"/-->
					<xsl:call-template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
						<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
						<xsl:with-param name="altova:nodeRow" select="$altova:nodeRow"/>
						<xsl:with-param name="altova:nColumn" select="1"/>
						<xsl:with-param name="altova:nCellInCurrentRow" select="1"/>
						<xsl:with-param name="altova:nColSpanInCellRemaining" select="$altova:nColSpan"/>
						<xsl:with-param name="altova:bColSpanBegins" select="true()"/>
						<xsl:with-param name="altova:nCurrentSum" select="0"/>
						<xsl:with-param name="altova:nRowSpansToAdd" select="0"/>
					</xsl:call-template>
				</altova:Row>
				<xsl:variable name="altova:seqActiveRowSpans_New" select="altova:BuildTableIndexInfo_ActiveRowSpans_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, 1, 1, $altova:nColSpan)" as="xs:integer*"/>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_Recursive($altova:nodeTableRows, $altova:nRow + 1, $altova:seqActiveRowSpans_New)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_Recursive">
					<xsl:with-param name="altova:nodeTableRows" select="$altova:nodeTableRows"/>
					<xsl:with-param name="altova:nRow" select="$altova:nRow + 1"/>
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans_New"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!--xsl:template name="altova:BuildTableIndexInfo_SingleRow_Recursive" as="node()*" xpath-default-namespace=""-->
	<xsl:template name="altova:BuildTableIndexInfo_SingleRow_Recursive" xpath-default-namespace="">
		<xsl:param name="altova:seqActiveRowSpans" as="xs:integer*"/>
		<xsl:param name="altova:nodeRow" as="node()"/>
		<xsl:param name="altova:nColumn" as="xs:integer"/>
		<xsl:param name="altova:nCellInCurrentRow" as="xs:integer"/>
		<xsl:param name="altova:nColSpanInCellRemaining" as="xs:integer"/>
		<xsl:param name="altova:bColSpanBegins" as="xs:boolean"/>
		<!-- Also true if it's just a single cell -->
		<xsl:param name="altova:nCurrentSum" as="xs:integer"/>
		<xsl:param name="altova:nRowSpansToAdd" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:nColumn gt count($altova:seqActiveRowSpans)">
				<xsl:sequence select="()"/>
			</xsl:when>
			<!-- If the cell is not under a rowspan -->
			<xsl:when test="$altova:seqActiveRowSpans[$altova:nColumn] eq 0">
				<!-- If the cell is not under a colspan -->
				<xsl:if test="$altova:bColSpanBegins eq true()">
					<!-- A non-spanned cell starts in this column -->
					<altova:ColumnIndex>
						<xsl:sequence select="$altova:nCurrentSum + 1"/>
					</altova:ColumnIndex>
				</xsl:if>
				<xsl:variable name="altova:nCellInCurrentRow_New" select="if ($altova:nColSpanInCellRemaining gt 1) then $altova:nCellInCurrentRow else $altova:nCellInCurrentRow + 1" as="xs:integer"/>
				<xsl:variable name="altova:nColSpanInCell_New" select="if ($altova:nColSpanInCellRemaining gt 1) then $altova:nColSpanInCellRemaining - 1 else if (empty(altova:GetCellFromRow($altova:nodeRow, $altova:nCellInCurrentRow_New))) then 1 else altova:col-span(altova:GetCellFromRow($altova:nodeRow, $altova:nCellInCurrentRow_New))" as="xs:integer"/>
				<xsl:variable name="altova:bColSpanBegins_New" select="$altova:nCellInCurrentRow ne $altova:nCellInCurrentRow_New" as="xs:boolean"/>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_SingleRow_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, $altova:nColumn + 1, $altova:nCellInCurrentRow_New, $altova:nColSpanInCell_New, $altova:bColSpanBegins_New, $altova:nCurrentSum + 1, $altova:nRowSpansToAdd)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
					<xsl:with-param name="altova:nodeRow" select="$altova:nodeRow"/>
					<xsl:with-param name="altova:nColumn" select="$altova:nColumn + 1"/>
					<xsl:with-param name="altova:nCellInCurrentRow" select="$altova:nCellInCurrentRow_New"/>
					<xsl:with-param name="altova:nColSpanInCellRemaining" select="$altova:nColSpanInCell_New"/>
					<xsl:with-param name="altova:bColSpanBegins" select="$altova:bColSpanBegins_New"/>
					<xsl:with-param name="altova:nCurrentSum" select="$altova:nCurrentSum + 1"/>
					<xsl:with-param name="altova:nRowSpansToAdd" select="$altova:nRowSpansToAdd"/>
				</xsl:call-template>
			</xsl:when>
			<!-- The cell is under a rowspan -->
			<xsl:otherwise>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_SingleRow_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, $altova:nColumn + 1, $altova:nCellInCurrentRow, $altova:nColSpanInCellRemaining, $altova:bColSpanBegins, $altova:nCurrentSum + 1, $altova:nRowSpansToAdd + 1)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
					<xsl:with-param name="altova:nodeRow" select="$altova:nodeRow"/>
					<xsl:with-param name="altova:nColumn" select="$altova:nColumn + 1"/>
					<xsl:with-param name="altova:nCellInCurrentRow" select="$altova:nCellInCurrentRow"/>
					<xsl:with-param name="altova:nColSpanInCellRemaining" select="$altova:nColSpanInCellRemaining"/>
					<xsl:with-param name="altova:bColSpanBegins" select="$altova:bColSpanBegins"/>
					<xsl:with-param name="altova:nCurrentSum" select="$altova:nCurrentSum + 1"/>
					<xsl:with-param name="altova:nRowSpansToAdd" select="$altova:nRowSpansToAdd + 1"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="altova:BuildTableIndexInfo_ActiveRowSpans_Recursive" as="xs:integer*" xpath-default-namespace="">
		<xsl:param name="altova:seqRowSpans" as="xs:integer*"/>
		<xsl:param name="altova:nodeCurrentRow" as="node()"/>
		<xsl:param name="altova:nColumn" as="xs:integer"/>
		<xsl:param name="altova:nCellInCurrentRow" as="xs:integer"/>
		<xsl:param name="altova:nColSpanInCellRemaining" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:nColumn gt count($altova:seqRowSpans)">
				<xsl:sequence select="()"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:nRowSpanForCurrentColumn" select="altova:BuildTableIndexInfo_ActiveRowSpans_SingleColumn($altova:seqRowSpans, $altova:nodeCurrentRow, $altova:nColumn, $altova:nCellInCurrentRow)" as="xs:integer?"/>
				<xsl:sequence select="$altova:nRowSpanForCurrentColumn"/>
				<xsl:variable name="altova:nCellInCurrentRow_New" select="if ($altova:seqRowSpans[$altova:nColumn] eq 0 and $altova:nColSpanInCellRemaining eq 1) then $altova:nCellInCurrentRow + 1 else $altova:nCellInCurrentRow" as="xs:integer"/>
				<xsl:variable name="altova:nColSpanInCell_New" select="if ($altova:seqRowSpans[$altova:nColumn] eq 0 and $altova:nCellInCurrentRow eq $altova:nCellInCurrentRow_New) then $altova:nColSpanInCellRemaining - 1 else if (empty(altova:GetCellFromRow($altova:nodeCurrentRow, $altova:nCellInCurrentRow_New))) then 1 else altova:col-span(altova:GetCellFromRow($altova:nodeCurrentRow, $altova:nCellInCurrentRow_New))" as="xs:integer"/>
				<xsl:sequence select="altova:BuildTableIndexInfo_ActiveRowSpans_Recursive($altova:seqRowSpans, $altova:nodeCurrentRow, $altova:nColumn + 1, $altova:nCellInCurrentRow_New, $altova:nColSpanInCell_New)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:BuildTableIndexInfo_ActiveRowSpans_SingleColumn" as="xs:integer?" xpath-default-namespace="">
		<xsl:param name="altova:seqRowSpans" as="xs:integer*"/>
		<xsl:param name="altova:nodeCurrentRow" as="node()"/>
		<xsl:param name="altova:nColumn" as="xs:integer"/>
		<xsl:param name="altova:nCellInCurrentRow" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:seqRowSpans[$altova:nColumn] gt 0">
				<xsl:sequence select="$altova:seqRowSpans[$altova:nColumn] - 1"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:nodeCell" select="altova:GetCellFromRow($altova:nodeCurrentRow, $altova:nCellInCurrentRow)" as="node()"/>
				<xsl:sequence select="altova:GetRowspanFromCell($altova:nodeCell) - 1"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartYValuesForSingleSeries">
		<xsl:param name="seqCategoryLeafPos" as="node()*"/>
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:for-each select="$seqCategoryLeafPos">
			<xsl:element name="altova:Value">
				<xsl:value-of select="altova:GetChartYValueForSingleSeriesPos($nodeSeriesLeafPos, ., $bValuesInCategory)"/>
			</xsl:element>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="altova:GetChartYValueForSingleSeriesPos">
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="nodeCategoryLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:variable name="altova:seqCategoryContextIds" select="$nodeCategoryLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:seqSeriesContextIds" select="$nodeSeriesLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:sCommonContextId" select="for $i in $altova:seqCategoryContextIds return if (some $j in $altova:seqSeriesContextIds satisfies $i eq $j) then $i else ()" as="xs:string*"/>
		<xsl:choose>
			<xsl:when test="count($altova:sCommonContextId) gt 1">
				<xsl:message select="concat('Found several values instead of a single one (contexts: ', string-join($altova:sCommonContextId, ', '), ').')" terminate="yes"/>
			</xsl:when>
			<xsl:when test="count($altova:sCommonContextId) lt 1">
				<xsl:message select="concat('XBRL Chart: Info: No value found for position labeled &quot;', $nodeCategoryLeafPos/@altova:sLabel, '&quot;')" terminate="no"/>
				<xsl:sequence select="'altova:no-value'"/>
			</xsl:when>
			<xsl:when test="$bValuesInCategory">
				<xsl:sequence select="xs:string($nodeCategoryLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="xs:string($nodeSeriesLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartLabelForPos" as="xs:string">
		<xsl:param name="nodeParam" as="node()"/>
		<xsl:value-of select="string-join($nodeParam/ancestor-or-self::altova:Pos/@altova:sLabel, ' ')"/>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-pixel" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="substring-before($normLength, 'px')"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * $altova:nPxPerIn"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * $altova:nPxPerIn div 2.54"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'mm')) * $altova:nPxPerIn div 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * $altova:nPxPerIn div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * $altova:nPxPerIn div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$normLength"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-mm" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'px')) div $altova:nPxPerIn * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * 10"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="substring-before($normLength, 'mm') "/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * 25.4 div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * 25.4 div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="number($normLength) div $altova:nPxPerIn * 25.4"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
</xsl:stylesheet>
