package verdict.DeliveryDrone;
import iml.lang.utils.*;
import verdict.Agree_Constants.*;
import iml.systems.*;
import verdict.Agree_Nodes.*;
import verdict.property_test.*;
import iml.verdict.*;
import iml.software.*;
import verdict.Data_Types.*;
import verdict.VERDICT_Properties.*;
import iml.contracts.*;
 
trait PositionEstimatorTrait  refines(Component, System) {
	gps_pos_in: InDataPort<Position_dot_impl>;
	imu_pos_in: InDataPort<Position_dot_impl>;
	est_pos_out: OutDataPort<Position_dot_impl>;
	pos_act_in: InDataPort<Position_dot_impl>;
	[CyberRel] CRel_pos_out_I : Bool :=  I(imu_pos_in) || I(gps_pos_in) || I(pos_act_in) =>  I(est_pos_out) ;
	
	[CyberRel] CRel_pos_out_A : Bool :=  A(imu_pos_in) || A(gps_pos_in) || A(pos_act_in) =>  A(est_pos_out) ;
	
			
			
};

type PositionEstimator  exhibits(PositionEstimatorTrait);
trait DeliveryPlannerTrait  refines(Component, System) {
	bus_in: InDataPort<InputBus_dot_impl>;
	nav_location: InDataPort<Position_dot_impl>;
	delivery_status: InDataPort<DeliveryStatus>;
	radio_response: InDataPort<RadioResponse_dot_impl>;
	camera_result: InDataPort<Int>;
	radio_cmd: OutDataPort<Bool>;
	delivery_cmd_out: OutDataPort<Bool>;
	dest_location: OutDataPort<Position_dot_impl>;
	bus_out: OutDataPort<Bool>;
	cmd_out: OutDataPort<Bool>;
	camera_out: OutDataPort<Bool>;
	p: OutDataPort<ProbePlannerSignals_dot_impl>;
	[CyberRel] CRel_dp_bus_out_I : Bool :=  I(nav_location) || I(delivery_status) || I(camera_result) || I(radio_response) =>  I(bus_out) ;
	
	[CyberRel] CRel_dp_bus_out_A : Bool :=  A(nav_location) || A(delivery_status) || A(camera_result) || A(radio_response) =>  A(bus_out) ;
	
	[CyberRel] CRel_dp_cmd_out_I : Bool :=  I(nav_location) || I(delivery_status) || I(camera_result) || I(radio_response) =>  I(cmd_out) ;
	
	[CyberRel] CRel_dp_cmd_out_A : Bool :=  A(nav_location) || A(delivery_status) || A(camera_result) || A(radio_response) =>  A(cmd_out) ;
	
	[CyberRel] CRel_dp_delivery_status_I : Bool :=  I(nav_location) || I(delivery_status) || I(camera_result) || I(radio_response) =>  I(delivery_cmd_out) ;
	
	[CyberRel] CRel_dp_delivery_status_A : Bool :=  A(nav_location) || A(delivery_status) || A(camera_result) || A(radio_response) =>  A(delivery_cmd_out) ;
	
	[CyberRel] CRel_dp_camera_out_I : Bool :=  I(nav_location) || I(delivery_status) || I(camera_result) || I(radio_response) =>  I(camera_out) ;
	
	[CyberRel] CRel_dp_camera_out_A : Bool :=  A(nav_location) || A(delivery_status) || A(camera_result) || A(radio_response) =>  A(camera_out) ;
	
	[CyberRel] CRel_dp_radio_cmd_I : Bool :=  I(nav_location) || I(delivery_status) || I(camera_result) || I(radio_response) =>  I(radio_cmd) ;
	
	[CyberRel] CRel_dp_radio_cmd_A : Bool :=  A(nav_location) || A(delivery_status) || A(camera_result) || A(radio_response) =>  A(radio_cmd) ;
	
			
			
};

type DeliveryPlanner  exhibits(DeliveryPlannerTrait);
trait IMUTrait  refines(Component, System) {
	launch_pos_in: InDataPort<Position_dot_impl>;
	imu_pos_out: OutDataPort<Position_dot_impl>;
	[CyberRel] CRel_imu_out_I : Bool :=  I(imu_pos_out) ;
	
	[CyberRel] CRel_imu_out_A : Bool :=  A(imu_pos_out) ;
	
			
			
};

type IMU  exhibits(IMUTrait);
trait DeliveryDroneSystemTrait  refines(Component, System) {
	satellite_sig_pos: InDataPort<Position_dot_impl>;
	launch_pos: InDataPort<Position_dot_impl>;
	bus1: InDataPort<InputBus_dot_impl>;
	comm1: InDataPort<RadioResponse_dot_impl>;
	comm2: OutDataPort<Bool>;
	bus2: OutDataPort<Bool>;
	radio_cmd: OutDataPort<Bool>;
	radio_response: OutDataPort<RadioResponse_dot_impl>;
	delivery_status: OutDataPort<DeliveryStatus>;
	delivery_cmd_out: OutDataPort<Bool>;
	actuation_out: OutDataPort<Bool>;
	[CyberReq{description="The drone shall be resilient to loss of ability to deliver a package to 
				              the appropriate consumer location" && severity=Severity.Hazardous && cia=CIA.I && targetLikelihood=TargetLikelihood.TL_None}] CReq_MissionReq01 : Bool := I(actuation_out) || A(actuation_out) || I(delivery_status) || A(delivery_status) ;
	
	[CyberReq{description="The drone shall be resilient to maliciously commanded improper delivery of a package" && severity=Severity.Hazardous && cia=CIA.I && targetLikelihood=TargetLikelihood.TL_None}] CReq_MissionReq02 : Bool := I(delivery_status) ;
	
			
			
};

type DeliveryDroneSystem  exhibits(DeliveryDroneSystemTrait);
type DeliveryDroneSystem_dot_Impl   exhibits(DeliveryDroneSystemTrait){
	[ verdict.VERDICT_Properties.VERDICT_Properties{ heterogeneityDAL=7 && adversariallyTested=true && insideTrustedBoundary=true && broadcastFromOutsideTB=true } , verdict.property_test.property_test{ pA=5.6 } ] gps : GPS;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ antiFuzzingDAL=7 && wifiFromOutsideTB=true && antiJamming=true && encryptionDAL=7 && antiFuzzing=true && antiFloodingDAL=7 && antiFlooding=true && antiJammingDAL=7 && insideTrustedBoundary=true && encryption=true } ] radio : Radio;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] imu : IMU;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] positionEstimator : PositionEstimator;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] navigation : Navigation;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] fc : FlightControl;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] actuation : Actuation;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ adversariallyTested=false && manufacturer=manufacturer_T.ThirdParty && componentType=componentType_T.Software && insideTrustedBoundary=true } ] deliveryPlanner : DeliveryPlanner;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] deliveryItemMechanism : DeliveryItemMechanism;
	[ verdict.VERDICT_Properties.VERDICT_Properties{ insideTrustedBoundary=true } ] camera : Camera;
	c1 : Connector<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(positionEstimator.est_pos_out, navigation.pos_in);
	assert{positionEstimator.est_pos_out.data = navigation.pos_in.data};
	c1b : Connector<InDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<InDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(launch_pos, imu.launch_pos_in);
	assert{launch_pos.data = imu.launch_pos_in.data};
	c2 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(navigation.move_out, fc.move_in);
	assert{navigation.move_out.data = fc.move_in.data};
	c3 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(fc.state_out, navigation.state_in);
	assert{fc.state_out.data = navigation.state_in.data};
	c4 : Connector<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(deliveryPlanner.dest_location, navigation.nav_dest_location);
	assert{deliveryPlanner.dest_location.data = navigation.nav_dest_location.data};
	c5 : Connector<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(navigation.nav_location_out, deliveryPlanner.nav_location);
	assert{navigation.nav_location_out.data = deliveryPlanner.nav_location.data};
	c7 : Connector<OutDataPort<DeliveryStatus>, InDataPort<DeliveryStatus>> := connect<OutDataPort<DeliveryStatus>, InDataPort<DeliveryStatus>>(deliveryItemMechanism.delivery_status_out, deliveryPlanner.delivery_status);
	assert{deliveryItemMechanism.delivery_status_out.data = deliveryPlanner.delivery_status.data};
	c9 : Connector<OutDataPort<Int>, InDataPort<Int>> := connect<OutDataPort<Int>, InDataPort<Int>>(camera.camera_out, deliveryPlanner.camera_result);
	assert{camera.camera_out.data = deliveryPlanner.camera_result.data};
	c10 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(deliveryPlanner.radio_cmd, radio.radio_in);
	assert{deliveryPlanner.radio_cmd.data = radio.radio_in.data};
	c11 : Connector<OutDataPort<RadioResponse_dot_impl>, InDataPort<RadioResponse_dot_impl>> := connect<OutDataPort<RadioResponse_dot_impl>, InDataPort<RadioResponse_dot_impl>>(radio.radio_out, deliveryPlanner.radio_response);
	assert{radio.radio_out.data = deliveryPlanner.radio_response.data};
	c12 : Connector<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(gps.gps_pos_out, positionEstimator.gps_pos_in);
	assert{gps.gps_pos_out.data = positionEstimator.gps_pos_in.data};
	c14 : Connector<InDataPort<InputBus_dot_impl>, InDataPort<InputBus_dot_impl>> := connect<InDataPort<InputBus_dot_impl>, InDataPort<InputBus_dot_impl>>(bus1, deliveryPlanner.bus_in);
	assert{bus1.data = deliveryPlanner.bus_in.data};
	c15 : Connector<OutDataPort<Bool>, OutDataPort<Bool>> := connect<OutDataPort<Bool>, OutDataPort<Bool>>(deliveryPlanner.bus_out, bus2);
	assert{deliveryPlanner.bus_out.data = bus2.data};
	c16 : Connector<InDataPort<RadioResponse_dot_impl>, InDataPort<RadioResponse_dot_impl>> := connect<InDataPort<RadioResponse_dot_impl>, InDataPort<RadioResponse_dot_impl>>(comm1, radio.comm_in);
	assert{comm1.data = radio.comm_in.data};
	c17 : Connector<OutDataPort<Bool>, OutDataPort<Bool>> := connect<OutDataPort<Bool>, OutDataPort<Bool>>(radio.comm_out, comm2);
	assert{radio.comm_out.data = comm2.data};
	c18a : Connector<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(imu.imu_pos_out, positionEstimator.imu_pos_in);
	assert{imu.imu_pos_out.data = positionEstimator.imu_pos_in.data};
	c19 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(fc.motor_cmd, actuation.motor_cmd_in);
	assert{fc.motor_cmd.data = actuation.motor_cmd_in.data};
	c20 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(actuation.response_out, fc.response_in);
	assert{actuation.response_out.data = fc.response_in.data};
	c22 : Connector<InDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<InDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(satellite_sig_pos, gps.satellite_pos_in);
	assert{satellite_sig_pos.data = gps.satellite_pos_in.data};
	c24 : Connector<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>> := connect<OutDataPort<Position_dot_impl>, InDataPort<Position_dot_impl>>(navigation.pos_act_out, positionEstimator.pos_act_in);
	assert{navigation.pos_act_out.data = positionEstimator.pos_act_in.data};
	c25 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(deliveryPlanner.delivery_cmd_out, deliveryItemMechanism.delivery_cmd_in);
	assert{deliveryPlanner.delivery_cmd_out.data = deliveryItemMechanism.delivery_cmd_in.data};
	c26 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(deliveryPlanner.cmd_out, navigation.cmd_in);
	assert{deliveryPlanner.cmd_out.data = navigation.cmd_in.data};
	c27 : Connector<OutDataPort<Bool>, InDataPort<Bool>> := connect<OutDataPort<Bool>, InDataPort<Bool>>(deliveryPlanner.camera_out, camera.camera_in);
	assert{deliveryPlanner.camera_out.data = camera.camera_in.data};
	c28 : Connector<OutDataPort<Bool>, OutDataPort<Bool>> := connect<OutDataPort<Bool>, OutDataPort<Bool>>(deliveryPlanner.radio_cmd, radio_cmd);
	assert{deliveryPlanner.radio_cmd.data = radio_cmd.data};
	c29 : Connector<OutDataPort<RadioResponse_dot_impl>, OutDataPort<RadioResponse_dot_impl>> := connect<OutDataPort<RadioResponse_dot_impl>, OutDataPort<RadioResponse_dot_impl>>(radio.radio_out, radio_response);
	assert{radio.radio_out.data = radio_response.data};
	c30 : Connector<OutDataPort<DeliveryStatus>, OutDataPort<DeliveryStatus>> := connect<OutDataPort<DeliveryStatus>, OutDataPort<DeliveryStatus>>(deliveryItemMechanism.delivery_status_out, delivery_status);
	assert{deliveryItemMechanism.delivery_status_out.data = delivery_status.data};
	c31 : Connector<OutDataPort<Bool>, OutDataPort<Bool>> := connect<OutDataPort<Bool>, OutDataPort<Bool>>(deliveryPlanner.delivery_cmd_out, delivery_cmd_out);
	assert{deliveryPlanner.delivery_cmd_out.data = delivery_cmd_out.data};
	c32 : Connector<OutDataPort<Bool>, OutDataPort<Bool>> := connect<OutDataPort<Bool>, OutDataPort<Bool>>(actuation.response_out, actuation_out);
	assert{actuation.response_out.data = actuation_out.data};
};

trait ActuationTrait  refines(Component, System) {
	response_out: OutDataPort<Bool>;
	motor_cmd_in: InDataPort<Bool>;
	[CyberRel] CRel_response_out_I : Bool :=  I(motor_cmd_in) =>  I(response_out) ;
	
	[CyberRel] CRel_response_out_A : Bool :=  A(motor_cmd_in) =>  A(response_out) ;
	
			
			
};

type Actuation  exhibits(ActuationTrait);
trait DeliveryItemMechanismTrait  refines(Component, System) {
	delivery_cmd_in: InDataPort<Bool>;
	delivery_status_out: OutDataPort<DeliveryStatus>;
	[CyberRel] CRel_delivery_status_out_I : Bool :=  I(delivery_cmd_in) =>  I(delivery_status_out) ;
	
	[CyberRel] CRel_delivery_status_out_A : Bool :=  A(delivery_cmd_in) =>  A(delivery_status_out) ;
	
			
			
};

type DeliveryItemMechanism  exhibits(DeliveryItemMechanismTrait);
trait CameraTrait  refines(Component, System) {
	camera_in: InDataPort<Bool>;
	camera_out: OutDataPort<Int>;
	[CyberRel] CRel_camera_out_I : Bool :=  I(camera_in) =>  I(camera_out) ;
	
	[CyberRel] CRel_camera_out_A : Bool :=  A(camera_in) =>  A(camera_out) ;
	
			
			
};

type Camera  exhibits(CameraTrait);
trait GPSTrait  refines(Component, System) {
	satellite_pos_in: InDataPort<Position_dot_impl>;
	gps_pos_out: OutDataPort<Position_dot_impl>;
	[CyberRel] CRel_dawRel : Bool :=  I(satellite_pos_in) ||( I(satellite_pos_in) && ! ( I(satellite_pos_in) || I(satellite_pos_in) ))=>  I(gps_pos_out) ;
	
	[CyberRel] CRel_gps_out_I : Bool :=  I(gps_pos_out) ;
	
	[CyberRel] CRel_gps_out_A : Bool :=  A(gps_pos_out) ;
	
			
			
};

type GPS  exhibits(GPSTrait);
trait RadioTrait  refines(Component, System) {
	comm_in: InDataPort<RadioResponse_dot_impl>;
	radio_in: InDataPort<Bool>;
	comm_out: OutDataPort<Bool>;
	radio_out: OutDataPort<RadioResponse_dot_impl>;
	[CyberRel] CRel_comm_out_I : Bool :=  I(comm_in) =>  I(comm_out) ;
	
	[CyberRel] CRel_comm_out_A : Bool :=  A(comm_in) =>  A(comm_out) ;
	
	[CyberRel] CRel_plan_out_I : Bool :=  I(radio_in) =>  I(radio_out) ;
	
	[CyberRel] CRel_plan_out_A : Bool :=  A(radio_in) =>  A(radio_out) ;
	
			
			
};

type Radio  exhibits(RadioTrait);
trait NavigationTrait  refines(Component, System) {
	pos_in: InDataPort<Position_dot_impl>;
	nav_dest_location: InDataPort<Position_dot_impl>;
	cmd_in: InDataPort<Bool>;
	state_in: InDataPort<Bool>;
	move_out: OutDataPort<Bool>;
	nav_location_out: OutDataPort<Position_dot_impl>;
	pos_act_out: OutDataPort<Position_dot_impl>;
	[CyberRel] CRel_move_out_I : Bool :=  I(pos_in) || I(cmd_in) || I(state_in) =>  I(move_out) ;
	
	[CyberRel] CRel_move_out_A : Bool :=  A(pos_in) || A(cmd_in) || A(state_in) =>  A(move_out) ;
	
	[CyberRel] CRel_nav_location_out_I : Bool :=  I(pos_in) || I(cmd_in) || I(state_in) =>  I(nav_location_out) ;
	
	[CyberRel] CRel_nav_location_out_A : Bool :=  A(pos_in) || A(cmd_in) || A(state_in) =>  A(nav_location_out) ;
	
	[CyberRel] CRel_pos_act_out_I : Bool :=  I(pos_in) || I(cmd_in) || I(state_in) =>  I(pos_act_out) ;
	
	[CyberRel] CRel_pos_act_out_A : Bool :=  A(pos_in) || A(cmd_in) || A(state_in) =>  A(pos_act_out) ;
	
			
			
};

type Navigation  exhibits(NavigationTrait);
trait FlightControlTrait  refines(Component, System) {
	motor_cmd: OutDataPort<Bool>;
	response_in: InDataPort<Bool>;
	state_out: OutDataPort<Bool>;
	move_in: InDataPort<Bool>;
	[CyberRel] CRel_state_out_I : Bool :=  I(move_in) || I(response_in) =>  I(state_out) ;
	
	[CyberRel] CRel_state_out_A : Bool :=  A(move_in) || A(response_in) =>  A(state_out) ;
	
	[CyberRel] CRel_fc_cmd_out_I : Bool :=  I(move_in) || I(response_in) =>  I(motor_cmd) ;
	
	[CyberRel] CRel_fc_cmd_out_A : Bool :=  A(move_in) || A(response_in) =>  A(motor_cmd) ;
	
			
			
};

type FlightControl  exhibits(FlightControlTrait);

