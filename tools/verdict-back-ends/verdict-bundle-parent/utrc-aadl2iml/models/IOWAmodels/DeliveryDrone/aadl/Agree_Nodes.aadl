package Agree_Nodes
public
	with Data_Types;
	
	annex agree {**
			
		-- HasHappened(X) is true iff X has been true at least once so far
		node HasHappened(X : bool) returns (Y : bool);
		let
  			Y = X or (false -> pre (X)) ;
		tel;

		-- Initially(X) is true iff X was true at the initial step
		node InitiallyX(X: bool) returns (Y: bool);
		let
  			Y = X -> true;
		tel;

		-- FirstLocation(X) is the constant stream consisting of the first value of X
		node FirstLocation( X : Data_Types::Position.impl ) returns ( Y : Data_Types::Position.impl );
		let
  			Y = X -> pre (Y);
		tel;
		
		node close_locations(p1: Data_Types::Position.impl, p2: Data_Types::Position.impl) returns (are_close: bool);
		let
  			are_close = p1 = p2;
		tel;
		
	**};
end Agree_Nodes;

--
--package Agree_Nodes
--public
--	with Data_Types;
--	
--	annex agree {**
--			
--		-- HasHappened(X) is true iff X has been true at least once so far
--		node HasHappened(X : int) returns (Y: int, Z: bool);
--		let
--  			Y = (1 -> pre (Y)) ;
--  			Z = (X = Y);
--		tel;
--
--		-- Initially(X) is true iff X was true at the initial step
--		node InitiallyX(X: bool) returns (Y: bool, Z: bool);
--		let
--  			Y = X -> true;
--  			Z = X;
--		tel;
--
--		-- FirstLocation(X) is the constant stream consisting of the first value of X
--		node FirstLocation( X : Data_Types::Position.impl ) returns ( Y : Data_Types::Position.impl );
--		let
--  			Y = X -> pre (Y);
--		tel;
--		
--		node close_locations(p1: Data_Types::Position.impl, p2: Data_Types::Position.impl) returns (are_close: bool);
--		let
--  			are_close = (p1 = p2);
--		tel;
--		
--	**};
--end Agree_Nodes;