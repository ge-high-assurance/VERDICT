package SW
public
	
	with Data_Model;
	with Base_Types;
	

	-- This is the structure to hold the lat/long/alt values of a coordinate
	data Coordinate
		
	end Coordinate;


	data implementation Coordinate.Impl
		subcomponents
			lat: data Base_Types::Integer;
			long: data Base_Types::Integer;
			alt: data Base_Types::Integer;
	end Coordinate.Impl;


	-- The Map is a structure that contains a list of coordinates that encircle a
	-- region.  
	-- In this implementation, we fix the size of the map to 4 waypoints
	data Map
		
	end Map;


	data implementation Map.Impl
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
	end Map.Impl;


	-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
	-- sensing region to conduct surveillance.
	data FlightPattern
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;

		-- The Command structure contains data that the Ground Station passes to the UAV.
		-- It contains a Map, Flight Pattern and Authentication bit.
	data Command
		
	end Command;
	

	data implementation Command.Impl
		subcomponents
			Map: data Map.Impl;
			Pattern: data FlightPattern;
			HMAC: data Base_Types::Boolean;
	end Command.Impl;

		-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
		-- Map and Flight Pattern.
		-- For this implementation, we fix the size of the Mission to 10 waypoints.
	data Mission
		
	end Mission;
	

	data implementation Mission.Impl
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
			wp5: data Coordinate.Impl;
			wp6: data Coordinate.Impl;
			wp7: data Coordinate.Impl;
			wp8: data Coordinate.Impl;
			wp9: data Coordinate.Impl;
			wp10: data Coordinate.Impl;
	end Mission.Impl;


	-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from
	-- the Mission.
	-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
	-- The crc value is an abstraction, which, if true, tells us that the data has not
	-- been corrupted.
	data MissionWindow
		
	end MissionWindow;


	data implementation MissionWindow.Impl
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
			crc: data Base_Types::Boolean;
	end MissionWindow.Impl;


	thread RadioDriver
		features
			recv_map_in: in event data port Command.Impl;
			send_status_out: out event data port Coordinate.Impl;
			send_status_in: in event data port Coordinate.Impl;
			recv_map_out: out event data port Command.Impl;
		annex agree {**
			assume Req001_RadioDriver "Authenticated command from the Ground Station" : recv_map_in.HMAC = True;
			guarantee Req002_RadioDriver "Authenticated command from the Ground Station" : recv_map_out.HMAC = True;
		**};
		annex iml {**
			[Assume{comment="Authenticated command from the Ground Station"}] Req001_RadioDriver : Bool := recv_map_in.data.HMAC = true;
			[Guarantee{comment="Authenticated command from the Ground Station"}] Req002_RadioDriver : Bool := recv_map_out.data.HMAC = true ; 
			assumption : Bool := Req001_RadioDriver;
			guarantee : Bool :=  Req002_RadioDriver ;
		**};
		
	end RadioDriver;
	
	
	thread implementation RadioDriver.Impl
		
	end RadioDriver.Impl;
	

	thread FlightPlanner
		features
			flight_plan: out data port Mission.Impl;
			recv_map: in event data port Command.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_FlightPlanner "The FlightPlanner shall receive a well-formed command from the GroundStation": good_command(recv_map);
			assume Req002_FlightPlanner "The Flight Planner shall receive an authenticated command from the Ground Station" : recv_map.HMAC = True;
			guarantee Req003_FlightPlanner "The Flight Planner shall generate a valid mission" : good_mission(flight_plan);
		**};
		annex iml {**
			[Assume{comment="The FlightPlanner shall receive a well-formed command from the GroundStation"}] Req001_FlightPlanner : Bool := recv_map.data.HMAC = true;
			[Assume{comment="The Flight Planner shall receive an authenticated command from the Ground Station"}] Req002_FlightPlanner : Bool := good_gs_command(recv_map.data);
			assumption : Bool := Req001_FlightPlanner && Req002_FlightPlanner ;
			[Guarantee{comment="The Flight Planner shall generate a valid mission"}] Req003_FlightPlanner :Bool := good_mission(flight_plan.data);
			guarantee : Bool := Req003_FlightPlanner;
		**} ;
	end FlightPlanner;
	
	
	thread implementation FlightPlanner.Impl
		
	end FlightPlanner.Impl;
	

	thread WaypointManager
		features
			flight_plan: in data port Mission.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_WaypointManager "The Waypoint Manager shall receive a well-formed mission" : good_mission(flight_plan);
			guarantee Req002_WaypointManager "The Waypoint Manager shall output a well-formed mission window" : good_mission_window(waypoint);
		**};
		annex iml {**
			[Assume{comment="The Waypoint Manager shall receive a well-formed mission"}] Req001_WaypointManager : Bool := good_mission(flight_plan.data);
			[Guarantee{comment="The Waypoint Manager shall output a well-formed mission window"}] Req002_WaypointManager : Bool := good_mission_window(waypoint.data);
			assumption : Bool := Req001_WaypointManager ;
			guarantee : Bool :=  Req002_WaypointManager ;
		**};
	end WaypointManager;
	
	
	thread implementation WaypointManager.Impl
		
	end WaypointManager.Impl;
	

	thread UARTDriver
		features
			position_status_in: in event data port Coordinate.Impl;
			waypoint_out: out event data port MissionWindow.Impl;
			position_status_out: out event data port Coordinate.Impl;
			waypoint_in: in event data port MissionWindow.Impl;
		annex agree {**
			assume Req001_UARTDriver "Well-formed mission window" : good_mission_window(waypoint_in);
			guarantee Req002_UARTDriver "A CRC shall be appended to the message to determine message correctness" : waypoint_out.crc = true;**};
		annex iml {**
			[Assume{comment="Well-formed mission window"}] Req001_UARTDriver : Bool := good_mission_window(waypoint_in.data);
			[Guarantee{comment="A CRC shall be appended to the message to determine message correctness"}] Req002_UARTDriver : Bool := waypoint_out.data.crc = true; 
			assumption : Bool := Req001_UARTDriver ;
			guarantee : Bool := Req002_UARTDriver ;
		**};
	end UARTDriver;
	
	
	thread implementation UARTDriver.Impl
		
	end UARTDriver.Impl;
	

	process MC_SW
		features
			recv_map: in event data port Command.Impl;
			send_status: out event data port Coordinate.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			-- we abstract away the authentication and just assume the message has undergone authenticity verification
			assume Req001_MC_SW "The Mission Computer shall only accept authenticated commands from the Ground Station" : recv_map.HMAC = True;
			assume Req002_MC_SW "The Mission Computer shall only accept authenticated commands from the Ground Station" : recv_map.HMAC = True;
			guarantee Req003_MC_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : waypoint.crc = True;**};
		annex iml {**
			[Assume{comment="The Mission Computer shall only accept authenticated commands from the Ground Station"}] Req001_MC_SW : Bool := recv_map.data.HMAC = true;
			[Assume{comment="The Mission Computer shall only accept authenticated commands from the Ground Station"}] Req002_MC_SW : Bool :=  recv_map.data.HMAC = true;
			[Guarantee{comment="The Mission Computer shall output a valid mission window to the Flight Controller" }] Req003_MC_SW : Bool := waypoint.data.crc = true; 
			assumption : Bool := Req001_MC_SW && Req002_MC_SW ;
			guarantee : Bool := Req003_MC_SW ;
		**} ;
	end MC_SW;


	process implementation MC_SW.Impl
		subcomponents
			RADIO: thread RadioDriver.Impl;
			FPLN: thread FlightPlanner.Impl;
			WPM: thread WaypointManager.Impl;
			UART: thread UARTDriver.Impl;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3: port RADIO.recv_map_out -> FPLN.recv_map;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port WPM.waypoint -> UART.waypoint_in;
			c7: port UART.position_status_out -> WPM.position_status;
			c8: port UART.position_status_out -> FPLN.position_status;
			c9: port UART.position_status_out -> RADIO.send_status_in;
			c10: port UART.waypoint_out -> waypoint;
			c11: port position_status -> UART.position_status_in;

	end MC_SW.Impl;


	annex agree {**
			
		-- These functions check the well-formedness of message structures
		fun good_coordinate(coord : Coordinate.Impl) : bool =	coord.lat >= -90 and 
																	coord.lat <= 90 and 
																	coord.long >= -180 and 
																	coord.long <= 180 and 
																	coord.alt >= 0 and 
																	coord.alt <= 15000;
																	
		fun good_map(map : Map.Impl) : bool =	good_coordinate(map.wp1) and 
													good_coordinate(map.wp2) and 
													good_coordinate(map.wp3) and 
													good_coordinate(map.wp4);
													
		fun good_pattern(pattern : FlightPattern) : bool =	(pattern = enum(FlightPattern, ZigZag)) or 
																(pattern = enum(FlightPattern, StraightLine)) or 
																(pattern = enum(FlightPattern, Perimeter));
																
		fun good_HMAC(hmac : bool) : bool = (hmac = True) or (hmac = False);
		
		fun good_command(cmd : Command.Impl) : bool =	good_map(cmd.Map) and 
																good_pattern(cmd.Pattern) and 
																good_HMAC(cmd.HMAC);
																
		fun good_mission(mission : Mission.Impl) : bool =	good_coordinate(mission.wp1) and 
																good_coordinate(mission.wp2) and 
																good_coordinate(mission.wp3) and 
																good_coordinate(mission.wp4) and 
																good_coordinate(mission.wp5) and 
																good_coordinate(mission.wp6) and 
																good_coordinate(mission.wp7) and 
																good_coordinate(mission.wp8) and 
																good_coordinate(mission.wp9) and 
																good_coordinate(mission.wp10);
																
		fun good_mission_window(win : MissionWindow.Impl) : bool =	good_coordinate(win.wp1) and 
																		good_coordinate(win.wp2) and 
																		good_coordinate(win.wp3) and 
																		good_coordinate(win.wp4);
	**};
	
	annex iml {**
		good_coordinate : Coordinate_dot_Impl -> Bool := fun(coord : Coordinate_dot_Impl) {
																coord.lat >= -90 && 
																coord.lat <= 90 && 
																coord.long >= -180 && 
																coord.long <= 180 && 
																coord.alt >= 0 && 
																coord.alt <= 15000 } ;
		good_map : Map_dot_Impl -> Bool := fun(map : Map_dot_Impl) {	
					 												good_coordinate(map.wp1) && 
																	good_coordinate(map.wp2) && 
																	good_coordinate(map.wp3) && 
																	good_coordinate(map.wp4) } ;
		good_pattern : FlightPattern -> Bool :=	fun(pattern : FlightPattern) {pattern = FlightPattern.ZigZag ||
																					  (pattern = FlightPattern.StraightLine) ||
																					   (pattern = FlightPattern.Perimeter)} ;
		good_HMAC : Bool -> Bool := fun(hmac : Bool) { (hmac = true) || (hmac = false) } ;
		good_gs_command : Command_dot_Impl -> Bool :=	fun(cmd : Command_dot_Impl) {good_map(cmd.Map) && 
																				good_pattern(cmd.Pattern) && 
																				good_HMAC(cmd.HMAC) };
		good_mission : Mission_dot_Impl -> Bool :=	fun( mission : Mission_dot_Impl) {good_coordinate(mission.wp1) && 
																				good_coordinate(mission.wp2) && 
																				good_coordinate(mission.wp3) && 
																				good_coordinate(mission.wp4) && 
																				good_coordinate(mission.wp5) && 
																				good_coordinate(mission.wp6) && 
																				good_coordinate(mission.wp7) && 
																				good_coordinate(mission.wp8) && 
																				good_coordinate(mission.wp9) && 
																				good_coordinate(mission.wp10) };
		good_mission_window : MissionWindow_dot_Impl -> Bool :=	fun(win : MissionWindow_dot_Impl) {good_coordinate(win.wp1) && 
																						good_coordinate(win.wp2) && 
																						good_coordinate(win.wp3) && 
																						good_coordinate(win.wp4)};
	**};


end SW;