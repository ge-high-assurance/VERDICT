--Designer vs. Analysis Engine
--Test C : Unknown

package UxASResponds_pkgC
public
	--Included DataTypes
	with Data_Model;  
    with Base_Types;
    
 	data RespondsState
		properties		
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("s0", "s1", "s2");
	end RespondsState;
	
	annex iml {**
		
		type [Fsm] responds_once{
			[Input]  a : Bool ;
			[Input]  b : Bool ;
			// State variable
			s : PrimedVar<RespondsState> ;
			// Initialization of the state variable
			[Init] s_init : Bool := { s.current = RespondsState.s0 } ;
			// Transition relation
			
			[Transition] state_trans : Bool := { 
					s.next =
						case {
							s.current = RespondsState.s0 && b && !a :  RespondsState.s1 ;
							s.current = RespondsState.s0 && a :  RespondsState.s2 ;
							s.current = RespondsState.s1 && a : RespondsState.s0 ;
							true : s.current ;
					}	  
			} ;
			// Definition of the output
			[Output] holds : Bool := ( s.current = RespondsState.s0 ||  s.current = RespondsState.s1 );
		}
		
		
		type [Fsm] one_request_at_a_time  {
			[Input]  a : Bool ;
			[Input]  b : Bool ;
			s : PrimedVar<RespondsState> ;
			[Init] s_init : Bool := {s = RespondsState.s0 } ;
			[Transition] s_trans : Bool := { 
				s.next = 
					case {
						s.current = RespondsState.s0 && b : RespondsState.s1 ;
						s.current = RespondsState.s1 && b : RespondsState.s2 ;
						s.current = RespondsState.s1 && a && ! b : RespondsState.s0 ;
						true : s.current ;
					}  	
			} ;
			[Output] holds : Bool :=  ( s.current = RespondsState.s0 ||  s.current = RespondsState.s1 );
		}
	**} ;
 	
 	  thread GenericService
    	features 
    	    CmdRequest_in: in event data port Base_Types::Boolean;
    	    CmdResponse_out: out event data port Base_Types::Boolean;
    	    
    	    SubRequest_out: out event data port Base_Types::Boolean;
    	    SubResponse_in: in event data port Base_Types::Boolean;
    	flows
			processing_path0 : flow path CmdRequest_in -> SubRequest_out  ;
			processing_path1 : flow path SubResponse_in -> CmdResponse_out;	
    	properties
    		-- This should be treated as a guarantee
    		-- There is no assumption
			latency => 1 ms .. 1ms applies to processing_path0, processing_path1;
	    annex iml {**
		  	
		  	g1monitor : responds_once ;
			c1 : Connector < Bool > := 
			<Bool>connect(CmdRequest_in.event,g1monitor.b);
			c2 : Connector < Bool > := 
			<Bool>connect(SubRequest_out.event,g1monitor.a);
			
			g2monitor : responds_once ;
			c3 : Connector < Bool > := 
			<Bool>connect(SubResponse_in.event,g2monitor.b);
			c4 : Connector < Bool > := 
			<Bool>connect(CmdResponse_out.event,g2monitor.a);
			
			d1 : delay ;
			c5 : Connector < FlowPath > := 
			<FlowPath>connect(processing_path0,d1.f);
			c6 : Connector < Int > := 
			<Int>connect(1,d1.n);
			
			d2 : delay ;
			c7 : Connector < FlowPath > := 
			<FlowPath>connect(processing_path1,d2.f);
			c8 : Connector < Int > := 
			<Int>connect(1,d2.n);
			
			[Guarantee,Output] g : Bool := {g1monitor.holds && g2monitor.holds && d1.holds && d2.holds};

			
	    **};
    end GenericService;
    
      thread GenericLastService
    	features 
    	    CmdRequest_in: in event data port Base_Types::Boolean;
    	    CmdResponse_out: out event data port Base_Types::Boolean;
    	annex iml {**
			gmonitor : responds_once ;
			c1 : Connector < Bool > := 
			<Bool>connect(CmdRequest_in.event,gmonitor.b);
			c2 : Connector < Bool > := 
			<Bool>connect(CmdResponse_out.event,gmonitor.a);
			
		
			[Guarantee,Output] g : Bool := {gmonitor.holds}  ;
			
	   	**};
    	
    end GenericLastService;
    
     
    process UxAS_responds
    	features
    		AutomationRequest_in: in event data port Base_Types::Boolean;
    		AutomationResponse_out: out event data port Base_Types::Boolean;	
    	flows
			processing_path : flow path AutomationRequest_in -> AutomationResponse_out;
		properties
			latency => 8 ms .. 8ms applies to processing_path;
    	annex iml {**
			
			amonitor : one_request_at_a_time ;
			adelaymonitor : one_request_at_a_time ;
			gmonitor : responds_once ;
			
			c1 : Connector < Bool > := 
			<Bool>connect(AutomationRequest_in.event,amonitor.b);
			c2 : Connector < Bool > := 
			<Bool>connect(AutomationResponse_out.event,amonitor.a);
			
			c11 : Connector < Bool > := 
			<Bool>connect(AutomationRequest_in.flowpoint.event,adelaymonitor.b);
			c21 : Connector < Bool > := 
			<Bool>connect(AutomationResponse_out.flowpoint.event,adelaymonitor.a);
			
			c3 : Connector < Bool > := 
			<Bool>connect(AutomationRequest_in.event,gmonitor.b);
			c4 : Connector < Bool > := 
			<Bool>connect(AutomationResponse_out.event,gmonitor.a);
			
			d : delay;
			c5 : Connector < FlowPath > := 
			<FlowPath>connect(processing_path,d.f);
			c6 : Connector < Int > := 
			<Int>connect(8,d.n);
			
			
			[Assumption,Output] a : Bool := {amonitor.holds && adelaymonitor.holds};
			[Guarantee,Output] g : Bool := {gmonitor.holds && d.holds};
	    					
    	**};
    end UxAS_responds;
 
    
    process implementation UxAS_responds.i
    	subcomponents
    		AutomationRequestValidator: thread GenericService;
    		PlanBuilder: thread GenericService;
    		TaskServiceBase: thread GenericService;
    		RouteAggregator: thread GenericService;
    		Planner: thread GenericLastService;
    	connections
    		-- Connection between Main System and AutomationRequestValidatorService : AutomationRq/Rs message pair
    		conn001: port AutomationRequest_in -> AutomationRequestValidator.CmdRequest_in;
    		conn002: port AutomationRequestValidator.CmdResponse_out -> AutomationResponse_out;
    		
    		-- Connection between AutomationRequestValidatorService and PlanBuilderService : UniqueAutomationRq/Rs message pair
    		conn011: port AutomationRequestValidator.SubRequest_out -> PlanBuilder.CmdRequest_in;
    	    conn012: port PlanBuilder.CmdResponse_out -> AutomationRequestValidator.SubResponse_in;
    	    
    	    -- Connection between PlanBuilderService and TaskServiceBase : TaskImplementationRq/Rs message pair
    	    conn021: port PlanBuilder.SubRequest_out -> TaskServiceBase.CmdRequest_in;
    	    conn022: port TaskServiceBase.CmdResponse_out -> PlanBuilder.SubResponse_in;
    	    
    	    -- Connection between TaskServiceBase and RouteAggregator : Route Rq/Rs message pair
    	    conn031: port TaskServiceBase.SubRequest_out -> RouteAggregator.CmdRequest_in;
    	    conn032: port RouteAggregator.CmdResponse_out -> TaskServiceBase.SubResponse_in;
    	    
    	    -- Connection between RouteAggregator and Planner: RoutePlan Rq/Rs message pair
    	    conn041: port RouteAggregator.SubRequest_out -> Planner.CmdRequest_in;
    	    conn042: port Planner.CmdResponse_out -> RouteAggregator.SubResponse_in;
    end UxAS_responds.i;

end UxASResponds_pkgC;